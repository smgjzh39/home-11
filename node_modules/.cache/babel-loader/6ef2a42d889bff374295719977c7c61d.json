{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util_1 = require(\"./util\");\n\nconst query_string_1 = require(\"query-string\");\n\nconst separator = \"|\";\n\nfunction latLngToString(o) {\n  if (typeof o === \"string\") {\n    return o;\n  } else if (Array.isArray(o) && o.length === 2) {// no transformation\n  } else if (\"lat\" in o && \"lng\" in o) {\n    o = [o.lat, o.lng];\n  } else if (\"latitude\" in o && \"longitude\" in o) {\n    o = [o.latitude, o.longitude];\n  } else {\n    throw new TypeError();\n  }\n\n  return o.map(x => {\n    return x.toString();\n  }).join(\",\");\n}\n\nexports.latLngToString = latLngToString;\n\nfunction objectToString(o) {\n  if (typeof o === \"string\") {\n    return o;\n  } else {\n    let keys = Object.keys(o);\n    keys.sort();\n    return keys.map(k => k + \":\" + o[k]).join(separator);\n  }\n}\n\nexports.objectToString = objectToString;\n\nfunction latLngBoundsToString(latLngBounds) {\n  if (typeof latLngBounds === \"string\") {\n    return latLngBounds;\n  } else {\n    return latLngToString(latLngBounds.southwest) + separator + latLngToString(latLngBounds.northeast);\n  }\n}\n\nexports.latLngBoundsToString = latLngBoundsToString;\n\nfunction toLatLngLiteral(o) {\n  if (typeof o === \"string\") {\n    const parts = o.split(\",\").map(Number);\n    return {\n      lat: parts[0],\n      lng: parts[1]\n    };\n  } else if (Array.isArray(o) && o.length === 2) {\n    const parts = o.map(Number);\n    return {\n      lat: parts[0],\n      lng: parts[1]\n    };\n  } else if (\"lat\" in o && \"lng\" in o) {\n    return o;\n  } else if (\"latitude\" in o && \"longitude\" in o) {\n    return {\n      lat: o.latitude,\n      lng: o.longitude\n    };\n  } else {\n    throw new TypeError();\n  }\n}\n\nexports.toLatLngLiteral = toLatLngLiteral;\n\nfunction latLngArrayToStringMaybeEncoded(o) {\n  if (typeof o === \"string\") {\n    return o;\n  }\n\n  const concatenated = o.map(latLngToString).join(separator);\n  const encoded = `enc:${util_1.encodePath(o.map(toLatLngLiteral))}`;\n\n  if (encoded.length < concatenated.length) {\n    return encoded;\n  }\n\n  return concatenated;\n}\n\nexports.latLngArrayToStringMaybeEncoded = latLngArrayToStringMaybeEncoded;\n\nfunction serializer(format, queryStringOptions = {\n  arrayFormat: \"separator\",\n  arrayFormatSeparator: separator\n}) {\n  return params => {\n    Object.keys(format).forEach(key => {\n      if (key in params) {\n        params[key] = format[key](params[key]);\n      }\n    });\n    return query_string_1.stringify(params, queryStringOptions);\n  };\n}\n\nexports.serializer = serializer;\n\nfunction toTimestamp(o) {\n  if (o === \"now\") {\n    return o;\n  }\n\n  if (o instanceof Date) {\n    return Number(o) / 1000;\n  }\n\n  return o;\n}\n\nexports.toTimestamp = toTimestamp;","map":{"version":3,"sources":["../src/serialize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\nconst query_string_1 = require(\"query-string\");\nconst separator = \"|\";\nfunction latLngToString(o) {\n    if (typeof o === \"string\") {\n        return o;\n    }\n    else if (Array.isArray(o) && o.length === 2) {\n        // no transformation\n    }\n    else if (\"lat\" in o && \"lng\" in o) {\n        o = [o.lat, o.lng];\n    }\n    else if (\"latitude\" in o && \"longitude\" in o) {\n        o = [o.latitude, o.longitude];\n    }\n    else {\n        throw new TypeError();\n    }\n    return o\n        .map((x) => {\n        return x.toString();\n    })\n        .join(\",\");\n}\nexports.latLngToString = latLngToString;\nfunction objectToString(o) {\n    if (typeof o === \"string\") {\n        return o;\n    }\n    else {\n        let keys = Object.keys(o);\n        keys.sort();\n        return keys.map((k) => k + \":\" + o[k]).join(separator);\n    }\n}\nexports.objectToString = objectToString;\nfunction latLngBoundsToString(latLngBounds) {\n    if (typeof latLngBounds === \"string\") {\n        return latLngBounds;\n    }\n    else {\n        return (latLngToString(latLngBounds.southwest) +\n            separator +\n            latLngToString(latLngBounds.northeast));\n    }\n}\nexports.latLngBoundsToString = latLngBoundsToString;\nfunction toLatLngLiteral(o) {\n    if (typeof o === \"string\") {\n        const parts = o.split(\",\").map(Number);\n        return { lat: parts[0], lng: parts[1] };\n    }\n    else if (Array.isArray(o) && o.length === 2) {\n        const parts = o.map(Number);\n        return { lat: parts[0], lng: parts[1] };\n    }\n    else if (\"lat\" in o && \"lng\" in o) {\n        return o;\n    }\n    else if (\"latitude\" in o && \"longitude\" in o) {\n        return { lat: o.latitude, lng: o.longitude };\n    }\n    else {\n        throw new TypeError();\n    }\n}\nexports.toLatLngLiteral = toLatLngLiteral;\nfunction latLngArrayToStringMaybeEncoded(o) {\n    if (typeof o === \"string\") {\n        return o;\n    }\n    const concatenated = o.map(latLngToString).join(separator);\n    const encoded = `enc:${util_1.encodePath(o.map(toLatLngLiteral))}`;\n    if (encoded.length < concatenated.length) {\n        return encoded;\n    }\n    return concatenated;\n}\nexports.latLngArrayToStringMaybeEncoded = latLngArrayToStringMaybeEncoded;\nfunction serializer(format, queryStringOptions = {\n    arrayFormat: \"separator\",\n    arrayFormatSeparator: separator,\n}) {\n    return (params) => {\n        Object.keys(format).forEach((key) => {\n            if (key in params) {\n                params[key] = format[key](params[key]);\n            }\n        });\n        return query_string_1.stringify(params, queryStringOptions);\n    };\n}\nexports.serializer = serializer;\nfunction toTimestamp(o) {\n    if (o === \"now\") {\n        return o;\n    }\n    if (o instanceof Date) {\n        return Number(o) / 1000;\n    }\n    return o;\n}\nexports.toTimestamp = toTimestamp;\n//# sourceMappingURL=serialize.js.map"]},"metadata":{},"sourceType":"script"}