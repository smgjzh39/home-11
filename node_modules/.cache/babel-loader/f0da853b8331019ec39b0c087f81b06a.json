{"ast":null,"code":"import e from \"axios\";\n\nfunction t(t) {\n  return (t = t || e).interceptors.response.use(n, s);\n}\n\nfunction r(t, r) {\n  (r = r || e).interceptors.response.eject(t);\n}\n\nfunction n(e) {\n  return e;\n}\n\nfunction o(e) {\n  var t = [];\n  if (e) return Array.isArray(e) ? e : (\"object\" == typeof e && Object.keys(e).forEach(function (r) {\n    \"number\" == typeof r && (t[r] = e[r]);\n  }), t);\n}\n\nfunction s(t) {\n  if (e.isCancel(t)) return Promise.reject(t);\n  var r = i(t) || {};\n  if (r.currentRetryAttempt = r.currentRetryAttempt || 0, r.retry = null == r.retry ? 3 : r.retry, r.retryDelay = r.retryDelay || 100, r.instance = r.instance || e, r.backoffType = r.backoffType || \"exponential\", r.httpMethodsToRetry = o(r.httpMethodsToRetry) || [\"GET\", \"HEAD\", \"PUT\", \"OPTIONS\", \"DELETE\"], r.noResponseRetries = null == r.noResponseRetries ? 2 : r.noResponseRetries, r.statusCodesToRetry = o(r.statusCodesToRetry) || [[100, 199], [429, 429], [500, 599]], t.config = t.config || {}, t.config.raxConfig = Object.assign({}, r), !(r.shouldRetry || function (e) {\n    var t = e.config.raxConfig;\n    if (!t || 0 === t.retry) return !1;\n    if (!e.response && (t.currentRetryAttempt || 0) >= t.noResponseRetries) return !1;\n    if (!e.config.method || t.httpMethodsToRetry.indexOf(e.config.method.toUpperCase()) < 0) return !1;\n\n    if (e.response && e.response.status) {\n      for (var r = !1, n = 0, o = t.statusCodesToRetry; n < o.length; n += 1) {\n        var s = o[n],\n            i = e.response.status;\n\n        if (i >= s[0] && i <= s[1]) {\n          r = !0;\n          break;\n        }\n      }\n\n      if (!r) return !1;\n    }\n\n    return t.currentRetryAttempt = t.currentRetryAttempt || 0, !(t.currentRetryAttempt >= t.retry);\n  })(t)) return Promise.reject(t);\n  var n = new Promise(function (e) {\n    var n;\n    n = \"linear\" === r.backoffType ? 1e3 * r.currentRetryAttempt : \"static\" === r.backoffType ? r.retryDelay : (Math.pow(2, r.currentRetryAttempt) - 1) / 2 * 1e3, t.config.raxConfig.currentRetryAttempt += 1, setTimeout(e, n);\n  }),\n      s = r.onRetryAttempt ? Promise.resolve(r.onRetryAttempt(t)) : Promise.resolve();\n  return Promise.resolve().then(function () {\n    return n;\n  }).then(function () {\n    return s;\n  }).then(function () {\n    return r.instance.request(t.config);\n  });\n}\n\nfunction i(e) {\n  if (e && e.config) return e.config.raxConfig;\n}\n\nexport { t as attach, r as detach, i as getConfig };","map":{"version":3,"sources":["../src/index.ts"],"names":["attach","instance","axios","interceptors","response","use","onFulfilled","onError","detach","interceptorId","eject","res","normalizeArray","obj","arr","Array","isArray","Object","keys","forEach","key","err","isCancel","Promise","reject","config","getConfig","currentRetryAttempt","retry","retryDelay","backoffType","httpMethodsToRetry","noResponseRetries","statusCodesToRetry","raxConfig","shouldRetry","onBackoffPromise","resolve","delay","Math","pow","setTimeout","onRetryAttemptPromise","onRetryAttempt","then","request","method","indexOf","toUpperCase","status","isInRange","const"],"mappings":"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","sourcesContent":["import axios, {\n  AxiosError,\n  AxiosInstance,\n  AxiosRequestConfig,\n  AxiosResponse,\n} from 'axios';\n\n/**\n * Configuration for the Axios `request` method.\n */\nexport interface RetryConfig {\n  /**\n   * The number of times to retry the request.  Defaults to 3.\n   */\n  retry?: number;\n\n  /**\n   * The number of retries already attempted.\n   */\n  currentRetryAttempt?: number;\n\n  /**\n   * The amount of time to initially delay the retry.  Defaults to 100.\n   */\n  retryDelay?: number;\n\n  /**\n   * The instance of the axios object to which the interceptor is attached.\n   */\n  instance?: AxiosInstance;\n\n  /**\n   * The HTTP Methods that will be automatically retried.\n   * Defaults to ['GET','PUT','HEAD','OPTIONS','DELETE']\n   */\n  httpMethodsToRetry?: string[];\n\n  /**\n   * The HTTP response status codes that will automatically be retried.\n   * Defaults to: [[100, 199], [429, 429], [500, 599]]\n   */\n  statusCodesToRetry?: number[][];\n\n  /**\n   * Function to invoke when a retry attempt is made.\n   */\n  onRetryAttempt?: (err: AxiosError) => void;\n\n  /**\n   * Function to invoke which determines if you should retry\n   */\n  shouldRetry?: (err: AxiosError) => boolean;\n\n  /**\n   * When there is no response, the number of retries to attempt. Defaults to 2.\n   */\n  noResponseRetries?: number;\n\n  /**\n   * Backoff Type; 'linear', 'static' or 'exponential'.\n   */\n  backoffType?: 'linear' | 'static' | 'exponential';\n}\n\nexport type RaxConfig = {\n  raxConfig: RetryConfig;\n} & AxiosRequestConfig;\n\n/**\n * Attach the interceptor to the Axios instance.\n * @param instance The optional Axios instance on which to attach the\n * interceptor.\n * @returns The id of the interceptor attached to the axios instance.\n */\nexport function attach(instance?: AxiosInstance) {\n  instance = instance || axios;\n  return instance.interceptors.response.use(onFulfilled, onError);\n}\n\n/**\n * Eject the Axios interceptor that is providing retry capabilities.\n * @param interceptorId The interceptorId provided in the config.\n * @param instance The axios instance using this interceptor.\n */\nexport function detach(interceptorId: number, instance?: AxiosInstance) {\n  instance = instance || axios;\n  instance.interceptors.response.eject(interceptorId);\n}\n\nfunction onFulfilled(res: AxiosResponse) {\n  return res;\n}\n\n/**\n * Some versions of axios are converting arrays into objects during retries.\n * This will attempt to convert an object with the following structure into\n * an array, where the keys correspond to the indices:\n * {\n *   0: {\n *     // some property\n *   },\n *   1: {\n *     // another\n *   }\n * }\n * @param obj The object that (may) have integers that correspond to an index\n * @returns An array with the pucked values\n */\nfunction normalizeArray<T>(obj?: T[]): T[] | undefined {\n  const arr: T[] = [];\n  if (!obj) {\n    return undefined;\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  if (typeof obj === 'object') {\n    Object.keys(obj).forEach(key => {\n      if (typeof key === 'number') {\n        arr[key] = obj[key];\n      }\n    });\n  }\n  return arr;\n}\n\nfunction onError(err: AxiosError) {\n  if (axios.isCancel(err)) {\n    return Promise.reject(err);\n  }\n\n  const config = getConfig(err) || {};\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n  config.retry =\n    config.retry === undefined || config.retry === null ? 3 : config.retry;\n  config.retryDelay = config.retryDelay || 100;\n  config.instance = config.instance || axios;\n  config.backoffType = config.backoffType || 'exponential';\n  config.httpMethodsToRetry = normalizeArray(config.httpMethodsToRetry) || [\n    'GET',\n    'HEAD',\n    'PUT',\n    'OPTIONS',\n    'DELETE',\n  ];\n  config.noResponseRetries =\n    config.noResponseRetries === undefined || config.noResponseRetries === null\n      ? 2\n      : config.noResponseRetries;\n\n  // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n  const retryRanges = [\n    // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n    // 1xx - Retry (Informational, request still processing)\n    // 2xx - Do not retry (Success)\n    // 3xx - Do not retry (Redirect)\n    // 4xx - Do not retry (Client errors)\n    // 429 - Retry (\"Too Many Requests\")\n    // 5xx - Retry (Server errors)\n    [100, 199],\n    [429, 429],\n    [500, 599],\n  ];\n  config.statusCodesToRetry =\n    normalizeArray(config.statusCodesToRetry) || retryRanges;\n\n  // Put the config back into the err\n  err.config = err.config || {}; // allow for wider range of errors\n  (err.config as RaxConfig).raxConfig = {...config};\n\n  // Determine if we should retry the request\n  const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n  if (!shouldRetryFn(err)) {\n    return Promise.reject(err);\n  }\n\n  // Create a promise that invokes the retry after the backOffDelay\n  const onBackoffPromise = new Promise(resolve => {\n    // Calculate time to wait with exponential backoff.\n    // Formula: (2^c - 1 / 2) * 1000\n    let delay: number;\n    if (config.backoffType === 'linear') {\n      delay = config.currentRetryAttempt! * 1000;\n    } else if (config.backoffType === 'static') {\n      delay = config.retryDelay!;\n    } else {\n      delay = ((Math.pow(2, config.currentRetryAttempt!) - 1) / 2) * 1000;\n    }\n\n    // We're going to retry!  Incremenent the counter.\n    (err.config as RaxConfig).raxConfig!.currentRetryAttempt! += 1;\n    setTimeout(resolve, delay);\n  });\n\n  // Notify the user if they added an `onRetryAttempt` handler\n  const onRetryAttemptPromise = config.onRetryAttempt\n    ? Promise.resolve(config.onRetryAttempt(err))\n    : Promise.resolve();\n\n  // Return the promise in which recalls axios to retry the request\n  return Promise.resolve()\n    .then(() => onBackoffPromise)\n    .then(() => onRetryAttemptPromise)\n    .then(() => config.instance!.request(err.config));\n}\n\n/**\n * Determine based on config if we should retry the request.\n * @param err The AxiosError passed to the interceptor.\n */\nfunction shouldRetryRequest(err: AxiosError) {\n  const config = (err.config as RaxConfig).raxConfig;\n\n  // If there's no config, or retries are disabled, return.\n  if (!config || config.retry === 0) {\n    return false;\n  }\n\n  // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n  if (\n    !err.response &&\n    (config.currentRetryAttempt || 0) >= config.noResponseRetries!\n  ) {\n    return false;\n  }\n\n  // Only retry with configured HttpMethods.\n  if (\n    !err.config.method ||\n    config.httpMethodsToRetry!.indexOf(err.config.method.toUpperCase()) < 0\n  ) {\n    return false;\n  }\n\n  // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n  if (err.response && err.response.status) {\n    let isInRange = false;\n    for (const [min, max] of config.statusCodesToRetry!) {\n      const status = err.response.status;\n      if (status >= min && status <= max) {\n        isInRange = true;\n        break;\n      }\n    }\n    if (!isInRange) {\n      return false;\n    }\n  }\n\n  // If we are out of retry attempts, return\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n  if (config.currentRetryAttempt >= config.retry!) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Acquire the raxConfig object from an AxiosError if available.\n * @param err The Axios error with a config object.\n */\nexport function getConfig(err: AxiosError) {\n  if (err && err.config) {\n    return (err.config as RaxConfig).raxConfig;\n  }\n  return;\n}\n\n// Include this so `config.raxConfig` works easily.\n// See https://github.com/JustinBeckwith/retry-axios/issues/64.\ndeclare module 'axios' {\n  export interface AxiosRequestConfig {\n    raxConfig?: RetryConfig;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}